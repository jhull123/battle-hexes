name: Deploy API to Dev

on:
  workflow_dispatch:

jobs:
  build-and-push-to-ecr:
    name: Build & Push Docker Image to ECR
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read

    outputs:
      image_tag: ${{ steps.meta.outputs.image_tag }}
      image_digest: ${{ steps.meta.outputs.image_digest }}
      image_uri_tag: ${{ steps.meta.outputs.image_uri_tag }}
      image_uri_digest: ${{ steps.meta.outputs.image_uri_digest }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials via OIDC
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      # (Optional but nice to have for emulation)
      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and push multi-arch Docker image to ECR
        env:
          ECR_REGISTRY: ${{ secrets.ECR_REGISTRY }}
          ECR_REPOSITORY: ${{ secrets.ECR_REPOSITORY }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          SHORT_SHA="${IMAGE_TAG::12}"

          # Build/push both a unique tag and latest
          docker buildx build \
            --platform linux/amd64,linux/arm64 \
            --provenance=false \
            -f battle_hexes_api/Dockerfile \
            -t "$ECR_REGISTRY/$ECR_REPOSITORY:$SHORT_SHA" \
            -t "$ECR_REGISTRY/$ECR_REPOSITORY:latest" \
            --push \
            .

          # Look up the manifest digest for the unique tag
          DIGEST=$(aws ecr describe-images \
            --repository-name "$ECR_REPOSITORY" \
            --image-ids imageTag="$SHORT_SHA" \
            --query 'imageDetails[0].imageDigest' \
            --output text)

          if [ -z "$DIGEST" ] || [ "$DIGEST" = "None" ]; then
            echo "Failed to resolve ECR image digest" >&2
            exit 1
          fi

          {
            echo "image_tag=$SHORT_SHA"
            echo "image_digest=$DIGEST"
            echo "image_uri_tag=$ECR_REGISTRY/$ECR_REPOSITORY:$SHORT_SHA"
            echo "image_uri_digest=$ECR_REGISTRY/$ECR_REPOSITORY@$DIGEST"
          } >> "$GITHUB_OUTPUT"
        id: meta

  deploy-cloudformation:
    name: Deploy CloudFormation Stack
    runs-on: ubuntu-latest
    needs: build-and-push-to-ecr
    permissions:
      id-token: write
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials via OIDC
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Deploy CloudFormation Stack (pin to digest)
        env:
          VPC_ID: ${{ secrets.VPC_ID }}
          SUBNET_IDS: ${{ secrets.SUBNET_IDS }}
          ECR_IMAGE: ${{ needs.build-and-push-to-ecr.outputs.image_uri_digest }}  # <â€” immutable
          ACM_CERT_ARN: ${{ secrets.ACM_CERT_ARN }}
          HOSTED_ZONE_ID: ${{ secrets.HOSTED_ZONE_ID }}
          API_DOMAIN_NAME: api-dev.battlehexes.com
        run: |
          # Ensure the ECS App Auto Scaling service-linked role exists (first time only)
          if ! aws iam get-role --role-name AWSServiceRoleForApplicationAutoScaling_ECSService >/dev/null 2>&1; then
            aws iam create-service-linked-role --aws-service-name ecs.application-autoscaling.amazonaws.com
          fi

          aws cloudformation deploy \
            --template-file battle_hexes_api/ecs-backend.yml \
            --stack-name battle-hexes-api-dev \
            --capabilities CAPABILITY_NAMED_IAM \
            --parameter-overrides \
              "VpcId=$VPC_ID" \
              SubnetIds="$SUBNET_IDS" \
              "EcrImage=$ECR_IMAGE" \
              AcmCertificateArn="$ACM_CERT_ARN" \
              HostedZoneId="$HOSTED_ZONE_ID" \
              ApiDomainName="$API_DOMAIN_NAME"

