name: Deploy API to Dev

on:
  workflow_dispatch:

jobs:
  build-and-push-to-ecr:
    name: Build & Push Docker Image to ECR
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read

    outputs:
      image_tag: ${{ steps.meta.outputs.image_tag }}
      image_digest: ${{ steps.meta.outputs.image_digest }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials via OIDC
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Set up QEMU
        if: runner.arch != 'ARM64'
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and push Docker image to ECR (arm64 + cache)
        env:
          ECR_REGISTRY: ${{ secrets.ECR_REGISTRY }}
          ECR_REPOSITORY: ${{ secrets.ECR_REPOSITORY }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          set -euo pipefail
          SHORT_SHA="${IMAGE_TAG::12}"

          # Build/push both a unique tag and latest
          docker buildx build \
            --platform linux/arm64 \
            --provenance=false \
            -f battle_hexes_api/Dockerfile \
            -t "$ECR_REGISTRY/$ECR_REPOSITORY:$SHORT_SHA" \
            -t "$ECR_REGISTRY/$ECR_REPOSITORY:latest" \
            --cache-from type=registry,ref=$ECR_REGISTRY/$ECR_REPOSITORY:buildcache \
            --cache-to   type=registry,ref=$ECR_REGISTRY/$ECR_REPOSITORY:buildcache,mode=max \
            --push \
            .

          # Look up the manifest digest for the unique tag
          DIGEST=$(aws ecr describe-images \
            --repository-name "$ECR_REPOSITORY" \
            --image-ids imageTag="$SHORT_SHA" \
            --query 'imageDetails[0].imageDigest' \
            --output text)

          if [ -z "$DIGEST" ] || [ "$DIGEST" = "None" ]; then
            echo "Failed to resolve ECR image digest" >&2
            exit 1
          fi

          {
            echo "image_tag=$SHORT_SHA"
            echo "image_digest=$DIGEST"
            echo "image_uri_tag=$ECR_REGISTRY/$ECR_REPOSITORY:$SHORT_SHA"
            echo "image_uri_digest=$ECR_REGISTRY/$ECR_REPOSITORY@$DIGEST"
          } >> "$GITHUB_OUTPUT"
        id: meta

  deploy-cloudformation:
    name: Deploy CloudFormation Stack
    runs-on: ubuntu-latest
    needs: build-and-push-to-ecr
    permissions:
      id-token: write
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials via OIDC
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ secrets.AWS_REGION }}

      # Compose full image URI locally (avoid secrets in job outputs)
      - name: Build final image URI (no secrets in outputs)
        id: compose
        run: |
          set -euo pipefail
          echo "uri=${{ secrets.ECR_REGISTRY }}/${{ secrets.ECR_REPOSITORY }}@${{ needs.build-and-push-to-ecr.outputs.image_digest }}" >> "$GITHUB_OUTPUT"

      # âœ… sanity check we actually have a value
      - name: Sanity-check image output
        run: |
          set -euo pipefail
          echo "IMAGE(digest) = ${{ needs.build-and-push-to-ecr.outputs.image_digest }}"
          echo "IMAGE(uri)    = ${{ steps.compose.outputs.uri }}"
          test -n "${{ steps.compose.outputs.uri }}"

      - name: Deploy CloudFormation Stack (pin to digest)
        env:
          VPC_ID: ${{ secrets.VPC_ID }}
          SUBNET_IDS: ${{ secrets.SUBNET_IDS }}
          ECR_IMAGE: ${{ steps.compose.outputs.uri }}  # repo@sha256:... (immutable)
          ACM_CERT_ARN: ${{ secrets.ACM_CERT_ARN }}
          HOSTED_ZONE_ID: ${{ secrets.HOSTED_ZONE_ID }}
          API_DOMAIN_NAME: api-dev.battlehexes.com
        run: |
          set -euo pipefail
          # Ensure the ECS App Auto Scaling service-linked role exists (first time only)
          if ! aws iam get-role --role-name AWSServiceRoleForApplicationAutoScaling_ECSService >/dev/null 2>&1; then
            aws iam create-service-linked-role --aws-service-name ecs.application-autoscaling.amazonaws.com
          fi

          aws cloudformation deploy \
            --template-file battle_hexes_api/ecs-backend.yml \
            --stack-name battle-hexes-api-dev \
            --capabilities CAPABILITY_NAMED_IAM \
            --parameter-overrides \
              "VpcId=$VPC_ID" \
              SubnetIds="$SUBNET_IDS" \
              "EcrImage=$ECR_IMAGE" \
              AcmCertificateArn="$ACM_CERT_ARN" \
              HostedZoneId="$HOSTED_ZONE_ID" \
              ApiDomainName="$API_DOMAIN_NAME"

